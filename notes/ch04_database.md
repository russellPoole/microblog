ch04_database.md

## Database

### Databases in Flask

* No native support for databases in Flask, by design.
* Two big types of of databases: relational and non-relational ("NoSQL")

Installing a few more Flask extensions:

* Flask-SQLAlchemy is an ORM to multiple databases: MySQL, PostgreSQL, SQLite
`(venv) $ pip install flask-sqlalchemy`

### Database Migrations

Migrations are necessary becuase data needs to be migrated to a new database schema, particularly in the case of non-additive schema operations.

Install Flask-Migrate, a wrapper for Alembic:

`(venv) $ pip install flask-migrate`

### Flask-SQLAlchemy Configuration

We'll use a SQLite database for development. These are file-based and don't require a database server.

Add the SQLite database information to `config.py`:

```python
import os
basedir = os.path.abspath(os.path.dirname(__file__))

class Config(object):
    # ...
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(basedir, 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
```

We can either use an environment variable to provide the location of the database or fallback to a default value of `sqlite:///<location of app>/app.db`

We also need to add import statements and create instances in `app/__init__.py` of :
* SQLAlchemy
* Migrate

We'll also import the `models` module to define the structure of the database.

### Database Models

Create a model that represents users, including:
* id INTEGER
* username VARCHAR (64)
* email VARCHAR (120)
* password hash VARCHAR (128)

An `id` field is usually present in all models and typically used as the _primary key_. This value is typically auto-assigned (auto-incremented) by the database on the creation of a new row.

Create the `app/models.py` module to begin building out models that will translate (automatically, via SQLAlchemy) into database schema representations.

```python
from app import db

class User(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(64), index=True, unique=True)
    email = db.Column(db.String(120), index=True, unique=True)
    password_hash = db.Column(db.String(128))

    def __repr__(self):
        return '<User {}>'.format(self.username)
```

We create a `User` class from the `db.Model`, a base class for all models from Flask-SQLAlchemy.

Fields are created as instances of the `db.Column` class, with the first argument _field type_, along with other optional arguments.

We create a field for each column we'd like to see in the `User` table and specify constraints such as _primary key_, _uniqueness_, etc.

Finally, we add a method (`__repr__(self)`) that allows us to print objects of this (`User()`) class in a Python interpreter session.

### Creating Migration Repository

Ensure that the `FLASK_APP` environment variable is set (in this case, to `microblog.py`)

`(venv) $ flask db init` will create the first instance of the database

- This will create a new migrations directory with instructions necessary for Alembic to migrate the database schema via SQL commands
- This migrations directory MUST be tracked in source control – it contains all of the successive instructions to assemble the database to a particular state

### The First Database Migration

`(venv) $ flask db migrate -m "<migration message>"`

- This will generate the first migration, which is a set of instructions to generate the users table that will map to the `User` database model.
- Alembic can create this migration automatically, and will automatically populate the migration script with changes needed to the database schema to match the application models.
- Because there is no previous database in this case, the automatic migration will add the entire User model to the migration script.
- Subsequent migrations may just be adding or removing a column, thereby only modifying the schema.
- The generated script is now part of the project and must remain with source control.
- The generated script has two functions: `upgrade()` and `downgrade()`
- `upgrade()` will apply the migration
- `downgrade()` will remove the migration

`(venv) $ flask db upgrade`

- This applies the migration script
- SQLite database is not found and is therefore created

### Database Upgrade and Downgrade Workflow

It is important to review the migration script generated by Alembic to ensure the expected model changes will take place after executing the migration. This can be tested safely in your development environment, perhaps even on a clone of production data to verify integrity after the operation.

You should not need to use the `downgrade()` function in Production unless something went very wrong. This function can allow you to easily downgrade in development, though. For example, perhaps a column wasn't created exactly as expected – downgrade and delete the latest migration script. Update the model, migrate, and upgrade to see the changes you intended to introduce.

### Database Relationships

Once a link between a user and post is established, the database can answer queries about this link. This includes bi-directional information (Get the author of a post. Get all posts by an author.)

Flask-SQLAlchemy can support both of these types of queries.

`users` table

* **id** (INTEGER)
* username (VARCHAR)
* email (VARCHAR)
* password_hash (VARCHAR)

`posts` table

* **id** (INTEGER)
* body (VARCHAR)
* timestamp (DATETIME)
* user_id (INTEGER)

In the schemas outlined above, we can establish a link between the _primary key_ of the `users` table (**id**) and a _foreign key_ (**user_id**) in the `posts` table.

This represents a one( user)-to-many( posts) relationship.

Add the following to `app/models.py`:

* import datetime
* create Post model
* create relationship in User model to Post model

Migrate and Upgrade the Database to now include the new posts table.

* `(venv) $ flask db migrate -m "posts table"`
* `(venv) $ flask db upgrade`

### Database Operations via Python Interpreter

By opening a `python` interpeter session, we can interact directly with the data through the models in the application.

```python
>>> from app import db
>>> from app.models import User, Post
>>> u = User(username='john', email='john@example.com')
>>> db.session.add(u)
>>> db.session.commit()
```

The above session will create a new instance of the User class. Once defined, we can use `db.session.add()` and `db.session.commit()` to prepare data for the database and commit our changes.

Add another and commit another user, Susan, using the same variable `u`, which will replace any notion of John in the interpreter instance.

Now let's run a query on the database that will return all (two) users we have added so far. We'll do this through the model we created in the application.

```python
>>> users = User.query.all()
>>> users
[<User john>, <User Susan>]
>>> for u in users:
...     print(u.id, u.username, u.email)
...
1 john john@example.com
2 Susan susan@example.com
```

All models have the `query` attribute, and the most basic query is one that returns all elements of a particular class: `all()`.

Another way to query is on the `id` of a user, if known:

```python
>>> u = User.query.get(1)
>>> u
<User john>
```

Now we can add a blog post that is authored by user with `id` = 1. We can do so by referencing the element returned to variable u instead of needing to specify a particular user id.

```python
>>> u = User.query.get(1)
>>> p = Post(body='my first post!', author=u)
>>> db.session.add(p)
>>> db.session.commit()
```

SQLAlchemy provides a nice high-level abstraction above relationships, keys, etc.

Some fun to show this in action:
```python
# get all posts written by a user
>>> u = User.query.get(1)
>>> u
<User john>
>>> posts = u.posts.all()
>>> posts
[<Post my first post!>]

# same but with a user that has no posts
>>> u = User.query.get(2)
>>> u
<User Susan>
>>> u.posts.all()
>>> []

# get all users in revers alphabetical order
>>> User.query.order_by(User.username.desc()).all()
[<User john>, <User Susan>]

# stage all users for deletion from the database
>>> users = User.query.all()
>>> for u in users:
...     db.session.delete(u)
...

# stage all posts for deletion from the database
>>> users = Post.query.all()
>>> for p in posts:
...     db.session.delete(p)
...

# commit staged deletion of users, posts
>>> db.session.commit()
```

### Shell Context

Using the Python shell is very helpful during the development of your application. Having to repeat certain imports every time you enter the shell is tedious and error-prone.

We can enter the shell with the full context of the application by using `flask shell`. This is the exact same as loading the application for use through a web browser, but swapping the UI for the interpreter.

We still need to add a function to `microblog.py` to register the items returned by it in the shell session.

```python
from app import app, db
from app.models import User, Post

@app.shell_context_processor
def make_shell_context():
    return {'db': db, 'User': User, 'Post': Post}
```